<head>
    <style type="text/css">
        html,
        body {
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body bgcolor=black>
    <center>
    <canvas id='canvas1' width="533px" height="300px"></canvas>
    
    <script>
    // THIS FUNCTION DOES ALL OF THE INITIALIZING FOR THE GPU PROGRAM.
    
    let start_gl = (canvas, meshData, vertexSize, vertexShader, fragmentShader) => {
    
       // GET THE 3D CONTEXT OF THE CANVAS
    
       let gl = canvas.getContext("webgl");
    
       // CREATE A PROGRAM THAT WILL RUN ON THE GPU
    
       let program = gl.createProgram();
       gl.program = program;
    
       // THIS IS HOW WE COMPILE AND ATTACH A SHADER TO THE GPU PROGRAM
    
       let addshader = (type, src) => {
          let shader = gl.createShader(type);
          gl.shaderSource(shader, src);
          gl.compileShader(shader);
          if (! gl.getShaderParameter(shader, gl.COMPILE_STATUS))
             throw "Cannot compile shader:\n\n" + gl.getShaderInfoLog(shader);
          gl.attachShader(program, shader);
       };
    
       // ADD THE VERTEX AND FRAGMENT SHADERS
    
       addshader(gl.VERTEX_SHADER  , vertexShader  );
       addshader(gl.FRAGMENT_SHADER, fragmentShader);
    
       // LINK THE PROGRAM AND REPORT ANY ERRORS
    
       gl.linkProgram(program);
       if (! gl.getProgramParameter(program, gl.LINK_STATUS))
          throw "Could not link the shader program!";
       gl.useProgram(program);
    
       // DECLARE A PLACE FOR MY VERTICES TO GO DOWN ON THE GPU
    
       gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    
       // PERMIT THE GPU TO RENDER NEARER THINGS IN FRONT OF FARTHER AWAY THINGS
    
       gl.enable(gl.DEPTH_TEST);
       gl.depthFunc(gl.LEQUAL);
    
       // SET ANY ONE ATTRIBUTE OF A VERTEX
    
       let vertexAttribute = (name, size, position) => {
          let attr = gl.getAttribLocation(program, name);
          gl.enableVertexAttribArray(attr);
          gl.vertexAttribPointer(attr, size, gl.FLOAT, false, vertexSize * 4, position * 4);
       }
    
       // SET THE POSITION ATTRIBUTE
    
       vertexAttribute('aPos', 3, 0);
    
       return gl;
    }
    
    // HERE WE ARE SETTING UP HOW THE CANVAS RESPONDS TO MOUSE EVENTS.
    
    let r = canvas1.getBoundingClientRect(), cursor = [0,0,0];
    let setCursor = (e, z) => cursor = [ (e.clientX - r.left) / canvas1.width * 2 - 1,
                                         1 - (e.clientY - r.top) / canvas1.height * 2,
                                         z !== undefined ? z : cursor[2] ];
    canvas1.onmousedown = e => setCursor(e, 1);
    canvas1.onmousemove = e => setCursor(e,  );
    canvas1.onmouseup   = e => setCursor(e, 0);
    
    // ALL OF THE 3D MESH SHAPES THAT WE ARE RENDERING (FOR NOW IT'S JUST ONE SHAPE)
    
    let meshData = [
       { type: 1, mesh: new Float32Array([ -1,1,0, 1,1,0, -1,-1,0, 1,-1,0 ]) },
    ];
    
    // THE VERTEX SHADER, FOLLOWED BY THE FRAGMENT SHADER
    
    let vertexSize = 3;
    let vertexShader = `
       attribute vec3 aPos;
       varying   vec3 vPos;
       void main() {
          gl_Position = vec4(aPos, 1.0);
          vPos = aPos;
       }
    `;
    let fragmentShader = `
    precision mediump float;
    #define AMPLITUDE 1. // the height of the waves
    varying vec3  vPos;
    float PI = 3.14159;
    uniform float iTime;

    struct Hit {
        vec3 point;
        vec3 dir;
        int hitOrca;
    };

    struct OceanHit {
        float d;
        int material;
    };

    float sdBox( vec3 p, vec3 b )
    {
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
    }

    float calcHeight(vec3 p) {
        float iter = 0.;
        float addedNoise = 0.;
        float frequency = .7;
        float weight = .8;
        float timeMultiplier = 2.3;
        float sum = 0.;
        for(float i = 1.; i < 30.; i += 1.) {
            vec2 p2 = vec2(sin(iter), cos(iter));
            vec3 waveDirection = vec3(p2.x, 0., p2.y);
            // line of wave: waveDirection.x * x + waveDirection.z * y + 0
            // therefore the distance from our current point to this line is
            float a = waveDirection.x;
            float b = waveDirection.z;
            float distToLine = abs(a * p.x + b * p.z + 15.) / sqrt(a*a + b*b);
            
            float addition = pow(3.5, sin(distToLine*frequency+iTime*timeMultiplier)-1.) * (weight);
            float dAddition = addition * cos(distToLine*frequency+iTime*timeMultiplier);
            p.xz += p2 * dAddition * weight * 0.1;
            
            addedNoise += addition;
            iter += 0.399963;
            weight *= 0.79;
            frequency *= 1.22;
            timeMultiplier /= 1.1;
            sum += weight;
        }
        return addedNoise*AMPLITUDE / sum;
    }

    // some of this inspired by https://www.shadertoy.com/view/MdXyzX
    float sceneOpaque(vec3 p) {
        vec3 np = p;
        np.y += 12.5;
        
        float oceanLocation = sdBox(np, vec3(40., 10., 40.))
                            -calcHeight(np);
        
        vec3 dP = p;
        dP.z += 3.;
        dP.y += 2.5;
        dP.y += calcHeight(dP)/2.;
        return oceanLocation;
    }

    float sceneWater(vec3 p) {
        //return opSmoothUnion(sceneOpaque(p), sdOrca(p), 1.);
        return sceneOpaque(p);
    }

    float sceneFull(vec3 p) {
        return sceneWater(p);
    }

    vec3 calcNormal(vec3 p) {
        vec2 h = vec2(.0001, 0); // Epsilon vector for swizzling
        vec3 normal = vec3(
        sceneFull(p+h.xyy) - sceneFull(p-h.xyy),   // x gradient
        sceneFull(p+h.yxy) - sceneFull(p-h.yxy),   // y gradient
        sceneFull(p+h.yyx) - sceneFull(p-h.yyx)    // z gradient
        );
        return normalize(normal);
    }

    vec3 refractedDir(vec3 normal, vec3 incident, float n1, float n2) {
        /*
        Vector refract(const Vector& normal, const Vector& incident, 
                double n1, double n2) 
            {
                const double n = n1 / n2;
                const double cosI = -dot(normal, incident);
                const double sinT2 = n * n * (1.0 - cosI * cosI);
                if(sinT2 > 1.0) return Vector::invalid; // TIR
                const double cosT = sqrt(1.0 - sinT2);
                return n * incident + (n * cosI - cosT) * normal;
            }
        */
        float n = n1/n2;
        float cosI = -dot(normal,incident);
        float sinT2 = n*n*(1.-cosI*cosI);
        float cosT = sqrt(1.-sinT2);
        return n*incident + (n*cosI - cosT)*normal;
    }


    // return where we hit, and the direction to move from there
    Hit newHit(Hit h) {
        Hit hit;
        hit.point = vec3(-111.);
        hit.dir = h.dir;
        hit.hitOrca = 0;
        
        vec3 ogPoint = h.point;
        vec3 ogDir = h.dir;
        
        ogPoint += normalize(ogDir)*0.011;
        for(int i = 0; i < 100; i++) {
            float distToWater = sceneWater(ogPoint);
            if(distToWater <= 0.01) {
                vec3 d = normalize(ogDir);
                vec3 n = calcNormal(ogPoint);
                vec3 r = d - 2.*(dot(d,n))*n;
                
                vec3 nDir = normalize(ogDir);
                float angle = acos(dot(nDir, n));
                
                hit.point = ogPoint;
                hit.dir = r;
                
                break;
            }
            ogPoint += normalize(ogDir)*distToWater;
        }
        return hit;
    }

    vec3 calcSkyColor(vec3 dir, float damper, int hitOrca) {
        vec3 ret = vec3(0.);
        ;
        //dir.y -= 0.05;
        ret.rgb = vec3((.6-abs(dir.y/1.5)));
        ret.g += 0.2;
        ret.b += 0.6;
        return clamp(ret / damper, 0., 1.);
    }


    void main(void)
    {
        // Calculate uv
        vec2 uv = vec2(vPos.x, vPos.y)*2.;
        uv.y = uv.y/(768./432.);
        
        vec3 lightPos = vec3(-0.8,-0.1,1.);
        vec3 lightColor = vec3(.8,0.8,0.3);
        
        vec3 translucentColor = vec3(0.5,0.5,1.);
    
        vec3 cam_origin = vec3(0.,0.,1.);
        vec3 rayDir = normalize(vec3(uv,0.) - cam_origin);
        float dist = 0.;
        float distToSphere = 0.;
        float distToCutS = 0.;
        vec3 camPos = cam_origin;
        vec3 color = vec3(0.);
        
        int entered = 0;
        float damper = 1.;
        float blurFactor = 0.;
        
        vec3 d;
        vec3 n;
        vec3 r;
        float distToWater;
        
        Hit hit;
        hit.point = camPos;
        hit.dir = rayDir;
        if(rayDir.y > 0.) {
            gl_FragColor = vec4(calcSkyColor(rayDir, 1., 0),1.);
            return;
        }
        for(int i = 0; i < 1; i++) {
            hit = newHit(hit);
            if(i == 0) {
                color = calcSkyColor(hit.dir, 1., hit.hitOrca);
            }
            if(hit.point == vec3(-111.)) {
                color = mix(color, calcSkyColor(hit.dir, 1., hit.hitOrca), 0.3);
            }
            if(i != 0) {
                color = mix(color, calcSkyColor(hit.dir, 1., hit.hitOrca), 0.3);
            }
        }
        
        if(hit.point != vec3(-111.)) {
            // genius by https://www.shadertoy.com/view/MdXyzX
            vec3 n = calcNormal(hit.point);
            n.y = abs(n.y);
            float dist = distance(camPos, hit.point);
            n = mix(n, vec3(0.0, 1.0, 0.0), min(1.0, sqrt(dist*0.5) * 1.1));
            float fres = (0.1 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-n, rayDir)), 5.0)));
            
            vec3 scattering = vec3(0.0493, 0.1598, 0.317)*1.2;
            
            color = fres * color + (1.0 - fres) * scattering;
            
        }
        
        gl_FragColor = vec4(color,1.);
    }
    `;
    
    // WAIT 100 MSECS BEFORE STARTING UP
    
    setTimeout(() => {
    
       // INITIALIZE GPU GRAPHICS
    
       let gl = start_gl(canvas1, meshData, vertexSize, vertexShader, fragmentShader);
    
       // PASS UNIFORM VARIABLES
    
       let iTime   = gl.getUniformLocation(gl.program, "iTime"  );
    
       // WHEN DID WE START ANIMATING?
    
       let startTime = Date.now() / 1000;
    
       // START THE ANIMATION LOOP
    
       setInterval(() => {
    
          // PASS ELAPSED TIME DOWN TO THE GPU
    
          gl.uniform1f (iTime, Date.now() / 1000 - startTime);
    
          // LOOP THROUGH ALL OF MY SHAPES
    
          for (let n = 0 ; n < meshData.length ; n++) {
    
             // PULL OUT THE ACTUAL MESH DATA
    
             let mesh = meshData[n].mesh;
    
         // LOAD THAT DATA DOWN INTO THE GPU
    
             gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
    
             // RENDER THAT DATA ACCORDING TO WHAT TYPE IT IS
    
             gl.drawArrays(meshData[n].type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
          }
       }, 30);
    }, 100);
    </script>
    
    
    
    
    
    
    
    