<head>
    <style type="text/css">
       canvas {
          height: 100vh;
          width: 100vh;
          z-index: -1;
       }
       p {
          color: white;
       }
    </style>
 </head>
 <body bgcolor=black>
 <center>
 <canvas id='canvas1' width=500 height=500></canvas>
 
 <script>
    let f = 1;
    let NUM_SPHERES = 50;
 /*
    This index.html file is very similar to the one that I gave you last week for
    homework 2.  The difference is that I am now defining a transformation matrix,
    which I pass down at each animation frame to the vertex shader to transform
    the rendered mesh shape.
 
    Directly below this text you will see the beginnings of a matrix library.
    I have already defined two helper functions: matrixIdentity and matrixMultiply.
    I also got you started by defining the matrix translation function mTranslate.
 
    When you run this index.html file in a Web browser, you will see that I am using
    mTranslate to make the rendered square move around in a circular motion.
 
    Homework 3 will be in two parts:
 
    (1) Properly implement the mRotateX, mRotateY, mRotateZ and mScale functions,
        which we defined in class this past week. For reference, you can review
        those lectures are in the Zoom recordings. Hint: The general form of each
        of these functions should look like my implementation of mTranslate below.
        The only difference is the first argument that you pass into the
        matrixMultiply function. Note that for each of these functions, the last
        argument is a matrix, and the return value is a suitably modified matrix.
 
    (2) Use a combination of mTranslate, mRotateX, mRotateY, mRotateZ and mScale
        to animate your square in interesting ways. See if you can make the square
        move and change over time in ways that are fun and surprising.
 */
 
 //////////////////////////////////////////////////////////////////////////////////////
 ///////////////////////// THE BEGINNINGS OF A MATRIX LIBRARY /////////////////////////
 
 let matrixIdentity = () => [ 1,0,0,0, 0,1,0,0, 0,0,1,-1/f, 0,0,0,1 ];
 
 let matrixMultiply = (a, b) => {
    let dst = [];
    for (let n = 0 ; n < 16 ; n++)
       dst.push(a[n&3]*b[n&12] + a[n&3|4]*b[n&12|1] + a[n&3|8]*b[n&12|2] + a[n&3|12]*b[n&12|3]);
    return dst;
 }
 
 let mTranslate = (tx,ty,tz, m) => {
    return matrixMultiply([1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1], m);
 }
 
 let mRotateX = (theta, m) => {
    let c = Math.cos(theta);
    let s = Math.sin(theta);
    return matrixMultiply([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1], m);
 }
 
 let mRotateY = (theta, m) => {
    let c = Math.cos(theta);
    let s = Math.sin(theta);
    return matrixMultiply([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1], m);
 }
 
 let mRotateZ = (theta, m) => {
    let c = Math.cos(theta);
    let s = Math.sin(theta);
    return matrixMultiply([c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1], m);
 }
 
 let mScale = (sx,sy,sz, m) => {
    return matrixMultiply([sx,0,0,0, 0,sy,0,0, 0,0,sz,0, 0,0,0,1], m);
 }
 
 //////////////////////////////////////////////////////////////////////////////////////
 //////////////////////////////////////////////////////////////////////////////////////
 
 
 // THIS FUNCTION DOES ALL OF THE INITIALIZING FOR THE GPU PROGRAM.
 
 let start_gl = (canvas, meshData, vertexSize, vertexShader, fragmentShader) => {
 
    // GET THE 3D CONTEXT OF THE CANVAS
 
    let gl = canvas.getContext("webgl");
 
    // CREATE A PROGRAM THAT WILL RUN ON THE GPU
 
    let program = gl.createProgram();
    gl.program = program;
 
    // THIS IS HOW WE COMPILE AND ATTACH A SHADER TO THE GPU PROGRAM
 
    let addshader = (type, src) => {
       let shader = gl.createShader(type);
       gl.shaderSource(shader, src);
       gl.compileShader(shader);
       if (! gl.getShaderParameter(shader, gl.COMPILE_STATUS))
          throw "Cannot compile shader:\n\n" + gl.getShaderInfoLog(shader);
       gl.attachShader(program, shader);
    };
 
    // ADD THE VERTEX AND FRAGMENT SHADERS
 
    addshader(gl.VERTEX_SHADER  , vertexShader  );
    addshader(gl.FRAGMENT_SHADER, fragmentShader);
 
    // LINK THE PROGRAM AND REPORT ANY ERRORS
 
    gl.linkProgram(program);
    if (! gl.getProgramParameter(program, gl.LINK_STATUS))
       throw "Could not link the shader program!";
    gl.useProgram(program);
 
    // DECLARE A PLACE FOR MY VERTICES TO GO DOWN ON THE GPU
 
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
 
    // PERMIT THE GPU TO RENDER NEARER THINGS IN FRONT OF FARTHER AWAY THINGS
 
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
 
    // SET ANY ONE ATTRIBUTE OF A VERTEX
 
    let vertexAttribute = (name, size, position) => {
       let attr = gl.getAttribLocation(program, name);
       gl.enableVertexAttribArray(attr);
       gl.vertexAttribPointer(attr, size, gl.FLOAT, false, vertexSize * 4, position * 4);
    }
 
    // SET THE POSITION ATTRIBUTE
 
    vertexAttribute('aPos', 3, 0);
 
    return gl;
 }
 
 // HERE WE ARE SETTING UP HOW THE CANVAS RESPONDS TO MOUSE EVENTS.
 
 let r = canvas1.getBoundingClientRect(), cursor = [0,0,0];
 let setCursor = (e, z) => cursor = [ (e.clientX - r.left) / canvas1.width * 2 - 1,
                                      1 - (e.clientY - r.top) / canvas1.height * 2,
                                      z !== undefined ? z : cursor[2] ];
 canvas1.onmousedown = e => setCursor(e, 1);
 canvas1.onmousemove = e => setCursor(e,  );
 canvas1.onmouseup   = e => setCursor(e, 0);
 
 // ALL OF THE 3D MESH SHAPES THAT WE ARE RENDERING (FOR NOW IT'S JUST ONE SHAPE)
 
 let meshData = [
    { type: 1, mesh: new Float32Array([ -1,1,0, 1,1,0, -1,-1,0, 1,-1,0]) },
 ];
 
 // THE VERTEX SHADER, FOLLOWED BY THE FRAGMENT SHADER
 
 let vertexSize = 3;
 let vertexShader = `
    attribute vec3 aPos;
    uniform mat4  uMatrix;
    varying   vec3 vPos;
    void main() {
       gl_Position = uMatrix * vec4(aPos, 1.0);
       gl_Position = vec4(gl_Position.xyz, gl_Position.z);
       vPos = aPos;
    }
 `;
 let fragmentShader = `
        precision mediump float;
        uniform float uTime;
        uniform vec3  uCursor;
        uniform vec2  uResolution;
        uniform vec4 uS[`+NUM_SPHERES+`];
        uniform vec3 uC[`+NUM_SPHERES+`];
        varying vec3  vPos;
        uniform vec3 uLightDir[2];
        float PI = 3.141592653;
     
        // changes the focal length, which changes how big the
        // differences in Z are

        float raySphere(vec3 V, vec3 W, vec4 S) {
            // simplify / unpack
            vec3 C = S.xyz;
            float r = S.w;// solve quadratic equation
            vec3 Vp = V - C;

            float b = dot(Vp, W);
            float c = dot(Vp,Vp) - r*r;
            float d = b*b - c;
            if(d > 0.) {
                return -b - sqrt(d);
            } else {
                return -1.;
            }
        }

        vec3 shadeSphere(vec4 S, vec3 P, vec3 L, vec3 color) {
            vec3 N = (P - S.xyz) / S.w;
            vec3 col = color * vec3(0.1 + .9*max(0., dot(N, L)));
            return col;
        }
     
        void main(void) {
            float fl = 2.;
            vec2 uv = vec2(vPos.x, vPos.y);
            uv.y = uv.y/(uResolution.x/uResolution.y);

            vec3 col = abs(vec3(sin(vPos.x), cos(vPos.y), sin(uTime/8.)));
            float brightness = sin(uTime) + 1.;
            brightness *= 0.5;
            col *= brightness;

            // form ray
            vec3 V = vec3(0.,0.,fl);
            vec3 W = normalize(vec3(vPos.xy,-fl));

            // make light source
            vec3 L = normalize(uLightDir[0]);
            vec3 L2 = normalize(uLightDir[1]);

            // shade sphere
            float tMin = 1000.;
            for(int n = 0; n < `+NUM_SPHERES+`; n++) {
                float t = raySphere(V, W, uS[n]);
                if(t > 0. && t < tMin) {
                  vec3 P = V + t * W;
                  vec3 tmp_col = shadeSphere(uS[n], P, L2, uC[n]);
                  col = tmp_col*(sin(uTime+PI)+1.25);
                  gl_FragColor = vec4(col, 1.);
                }
            }

            gl_FragColor = vec4(col, 1.);
        }
     `;
 
 // WAIT 100 MSECS BEFORE STARTING UP
 
 setTimeout(() => {
 
    // INITIALIZE GPU GRAPHICS
 
    let gl = start_gl(canvas1, meshData, vertexSize, vertexShader, fragmentShader);
 
    // PASS UNIFORM VARIABLES
    let uTime   = gl.getUniformLocation(gl.program, "uTime"  );
    let uCursor = gl.getUniformLocation(gl.program, "uCursor");
    let uMatrix = gl.getUniformLocation(gl.program, "uMatrix");
    let uResolution = gl.getUniformLocation(gl.program, "uResolution");
    let uS = gl.getUniformLocation(gl.program, "uS");
    let uC = gl.getUniformLocation(gl.program, "uC");
    let uLightDir = gl.getUniformLocation(gl.program, "uLightDir");
 
 
    // WHEN DID WE START ANIMATING?
 
    let startTime = Date.now() / 1000;
 
    // START THE ANIMATION LOOP
 
    let count = 0;
    setInterval(() => {
 
       // PASS ELAPSED TIME DOWN TO THE GPU
 
       let time = Date.now() / 1000 - startTime;
       gl.uniform1f (uTime, time);
 
       gl.uniform2fv(uResolution, [window.innerWidth,window.innerHeight]);
 
       // PASS THE CURSOR STATE DOWN TO THE GPU
 
       gl.uniform3fv(uCursor, cursor);

       let uLightDir_val = [Math.sin(time/2), Math.cos(time/2), 1,
                            Math.cos(time/2), Math.sin(time/2), 1];
       gl.uniform3fv(uLightDir, uLightDir_val);

       let ss = Math.sin(time/2.);
       let numSpheres = NUM_SPHERES;
       let radius = 0;
       let rad_incr = .004;
       let angle = 0;
       let uS_val = []
       let uS_len = numSpheres * 4;
       let uC_val = []
       let uC_len = numSpheres * 3;
       let spin = time/10;
       for(let i = 0; i < numSpheres; i++) {
         scalar = 1;
         scalar = 0.25 + (i)/100;
         radius += rad_incr / scalar;
         angle += Math.PI / 2 / scalar / 7 + spin;
         let x = Math.cos(angle) * radius;
         let y = Math.sin(angle) * radius;
         let z = i/numSpheres*13-10;
         uS_val[i*4] = x;
         uS_val[i*4+1] = y;
         uS_val[i*4+2] = z;
         uS_val[i*4+3] = 0.04;
         uC_val[i*3] = Math.abs(Math.sin((i+time*5)/10));
         uC_val[i*3+1] = Math.abs(Math.cos((i+time*5)/10));
         uC_val[i*3+2] = Math.abs(Math.sin((i+time*5)/10));
       }
       gl.uniform4fv(uS, uS_val);
       gl.uniform3fv(uC, uC_val);

 
 ///////////////////////////////////////////////////////////////////////////////
 //// HERE YOU CAN DEFINE YOUR ANIMATION AS A SEQUENCE OF MATRIX OPERATIONS ////
 
       let c = .5 * Math.cos(time);
       let s = .5 * Math.sin(time);
 
       f = -1;
       let m = matrixIdentity();
       /*
       m = mTranslate(0,0,0.7,m);
       m = mRotateZ(time*c,m);
       */
       gl.uniformMatrix4fv(uMatrix, false, m);
 
 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////
 
       // LOOP THROUGH ALL OF MY SHAPES
 
       for (let n = 0 ; n < meshData.length ; n++) {
 
          // PULL OUT THE ACTUAL MESH DATA
 
          let mesh = meshData[n].mesh;
          let z_value = 0.7;
          mesh[2] = z_value;
          mesh[5] = z_value;
          mesh[8] = z_value;
          mesh[11] = z_value;
 
      // LOAD THAT DATA DOWN INTO THE GPU
 
          gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
 
          // RENDER THAT DATA ACCORDING TO WHAT TYPE IT IS
 
          gl.drawArrays(meshData[n].type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
       }
    }, 1);
 }, 100);
 </script> 